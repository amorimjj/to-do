---
alwaysApply: true
description: Types handling instructions
globs: **/*
---

# Types

## Rules

- Define types OUTSIDE function/component declarations
- Keep types in SAME FILE as usage when it just need locally
- Move types into types.ts when it needs to be shared between files
- Never create separate `types.ts` files unless shared
- Prefer API types → Custom types
- Avoid use of "as" - prefer type refinement functions and conditional statements
- Exception: `as` assertions are acceptable when working with external library types that don't provide strict typing


## Utility Types

```typescript
// Derive from existing types
type UserName = Pick<User, "name" | "email">;
type PartialUser = Partial<User>;
type UserWithoutId = Omit<User, "id">;
```

## Component Props

```typescript
// ✅ GOOD: Define outside component
interface UserCardProps {
  user: RouterOutputs["users"]["get"];
  onSelect?: (id: string) => void;
}

export function UserCard({ user, onSelect }: UserCardProps) {
  return <div>{user.name}</div>;
}

// ❌ BAD: Define inside component
export function UserCard({ user }: { user: User }) {
  return <div>{user.name}</div>;
}
```

## Type Assertions

**General Rule:** Avoid `as` type assertions. Use type refinement functions and conditional statements instead.

**Exception for External Library Types:**

When working with external libraries that don't provide strict typing, `as` assertions are acceptable when combined with nullish coalescing and proper defaults:

**Best Practices:**
- Always use nullish coalescing (`??`) with `as` assertions for external library types
- Prefer type guard functions when the same check is used multiple times
- Document why `as` is necessary (external library limitation)
- Never use `as` to bypass TypeScript's type checking for our own types
```
